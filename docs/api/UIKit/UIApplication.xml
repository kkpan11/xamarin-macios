<Documentation>
  <Docs DocId="T:UIKit.UIApplication">
    <summary>Encapsulates the main processing loop for a MonoTouch application.</summary>
    <remarks>
      <para> 
	The <see cref="UIKit.UIApplication" />
	encapsulates the central administrative properties of an
	application running on iOS. Application developers must not
	instantiate new <see cref="UIKit.UIApplication" />s using constructors, but instead must use the static <see cref="UIKit.UIApplication.SharedApplication" />
        singleton property. Application developers may subclass <see cref="UIKit.UIApplication" /> and use the <c>principalClassName</c> argument to the <see cref="UIKit.UIApplication.Main(string[],string,string)" /> method to specify their subclass. In that situation, developers must create a public constructor for their subclass that the runtime will call appropriately. Subsequently, the <see cref="UIKit.UIApplication.SharedApplication" /> singleton will refer to the instance of their subclass.</para>
      <para> 
	Unlike with most classes in the <see cref="UIKit" /> namespace, events relating to the
        <see cref="UIKit.UIApplication" /> cannot be
        handled using C#-style events but rather only by the
        Objective-C style <see cref="UIKit.UIApplicationDelegate" /> delegate
        style.  </para>
      <para> 
	The <see cref="UIKit.UIApplication" /> object
        is responsible for maintaining the highest-level context of
        the application, such as the <see cref="UIKit.UIApplication.ApplicationState" />,
        the set of open windows (<see cref="UIKit.UIApplication.Windows" />), and
        functions relating to notifications (see also <see cref="UIKit.UIAppearance.Notifications.xml" />). Additionally, the <see cref="UIKit.UIApplication.UIApplication" /> method may
        be used to launch another application.  </para>
      <para> 
	The <see cref="UIKit.UIApplication" /> class
        contains methods relating to background processing, such as
        <see cref="UIKit.UIApplication.EnsureUIThread" />,
        <see cref="UIKit.UIApplication.BeginBackgroundTask(System.String,System.Action)" />,
        and <see cref="UIKit.UIApplication.EndBackgroundTask(System.IntPtr)" />.
        </para>
      <format type="text/html">
        <h2>Background Fetch</h2>
      </format>
      <para> 
	Starting with iOS 7, applications can request that they be
	woken up to download data from the server in the background.
	When this feature is enabled, the operating system will resume
	the application or launch the application at some point to
	allow the application to download any new contents it needs
	from the server.

      </para>
      <para>
	To use this, applications need to have the "fetch" background
	operation requested on their requested Entitlements as well as
	calling the <see cref="UIKit.UIApplication.SetMinimumBackgroundFetchInterval(System.Double)" />
	method with the desired wake up interval at launch.   

      </para>
      <para>
	When the operating system determines that the application
	should be resumed to download data, the <see cref="UIKit.UIApplicationDelegate.PerformFetch(UIKit.UIApplication,System.Action{UIKit.UIBackgroundFetchResult})" />
	method will be invoked.  This method should perform any
	downloads and then notify the operating system of the result
	of the operation.

      </para>
      <para>
	Applications do not really have control of when the
	application will be launched.  The actual launch time is
	determined by a set of heuristics based that the operating
	system tracks based on how the user uses the application, as
	well as tracking the status of previous download operations
	that the application has done.

      </para>
      <format type="text/html">
        <h2>Remote Notifications</h2>
      </format>
      <para> 
	Starting with iOS 7, applications can request that they be
	woken up when a remote notification is received.  When this
	feature is enabled, the operating system will resume the
	application and invoke the <see cref="UIKit.UIApplicationDelegate_Extensions.DidReceiveRemoteNotification(UIKit.IUIApplicationDelegate,UIKit.UIApplication,Foundation.NSDictionary,System.Action{UIKit.UIBackgroundFetchResult})" />
	overload that takes a completion handler parameter and let it
	run.

      </para>
      <para>
	To use this, applications need to have the "remote-notification" background
	operation requested on their requested Entitlements as.

      </para>
    </remarks>
    <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/index.html">Apple documentation for <c>UIApplication</c></related>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.UserDidTakeScreenshotNotification">
    <summary>Notification constant for UserDidTakeScreenshot</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveUserDidTakeScreenshot" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveUserDidTakeScreenshot ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveUserDidTakeScreenshot (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.UserDidTakeScreenshotNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.UserDidTakeScreenshotNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.BackgroundRefreshStatusDidChangeNotification">
    <summary>Notification constant for BackgroundRefreshStatusDidChange</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.BackgroundRefreshStatusDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.BackgroundRefreshStatusDidChangeNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.ContentSizeCategoryChangedNotification">
    <summary>Notification constant for ContentSizeCategoryChanged</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIApplication.Notifications.ObserveContentSizeCategoryChanged" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveContentSizeCategoryChanged ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("WeakNewValue", args.WeakNewValue);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIContentSizeCategoryChangedEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("WeakNewValue", args.WeakNewValue);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveContentSizeCategoryChanged (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ContentSizeCategoryChangedNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ContentSizeCategoryChangedNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.WillEnterForegroundNotification">
    <summary>Notification constant for WillEnterForeground</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveWillEnterForeground" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillEnterForeground ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillEnterForeground (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillEnterForegroundNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillEnterForegroundNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.DidEnterBackgroundNotification">
    <summary>Notification constant for DidEnterBackground</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveDidEnterBackground" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidEnterBackground ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidEnterBackground (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidEnterBackgroundNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidEnterBackgroundNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.ProtectedDataDidBecomeAvailable">
    <summary>Indicates that the state of protected data has changed.</summary>
    <value>To be added.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ProtectedDataDidBecomeAvailable, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ProtectedDataDidBecomeAvailable, Callback);
}
]]></code>
      </example>
    </remarks>
    <altmember cref="UIKit.UIApplication.ProtectedDataAvailable" />
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.ProtectedDataWillBecomeUnavailable">
    <summary>Indicates that the state of protected data has changed.</summary>
    <value>To be added.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ProtectedDataWillBecomeUnavailable, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ProtectedDataWillBecomeUnavailable, Callback);
}
]]></code>
      </example>
    </remarks>
    <altmember cref="UIKit.UIApplication.ProtectedDataAvailable" />
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.SignificantTimeChangeNotification">
    <summary>Notification constant for SignificantTimeChange</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveSignificantTimeChange" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveSignificantTimeChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveSignificantTimeChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.SignificantTimeChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.SignificantTimeChangeNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.WillTerminateNotification">
    <summary>Notification constant for WillTerminate</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveWillTerminate" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillTerminate ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillTerminate (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillTerminateNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillTerminateNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.DidReceiveMemoryWarningNotification">
    <summary>Notification constant for DidReceiveMemoryWarning</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveDidReceiveMemoryWarning" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidReceiveMemoryWarning ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidReceiveMemoryWarning (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidReceiveMemoryWarningNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidReceiveMemoryWarningNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.WillResignActiveNotification">
    <summary>Notification constant for WillResignActive</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveWillResignActive" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillResignActive ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillResignActive (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillResignActiveNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillResignActiveNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.DidBecomeActiveNotification">
    <summary>Notification constant for DidBecomeActive</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveDidBecomeActive" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidBecomeActive ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidBecomeActive (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidBecomeActiveNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidBecomeActiveNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.DidFinishLaunchingNotification">
    <summary>Notification constant for DidFinishLaunching</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIApplication.Notifications.ObserveDidFinishLaunching" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidFinishLaunching ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("Url", args.Url);
    Console.WriteLine ("SourceApplication", args.SourceApplication);
    Console.WriteLine ("RemoteNotifications", args.RemoteNotifications);
    Console.WriteLine ("LocationLaunch", args.LocationLaunch);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIApplicationLaunchEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("Url", args.Url);
    Console.WriteLine ("SourceApplication", args.SourceApplication);
    Console.WriteLine ("RemoteNotifications", args.RemoteNotifications);
    Console.WriteLine ("LocationLaunch", args.LocationLaunch);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidFinishLaunching (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidFinishLaunchingNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidFinishLaunchingNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.DidFinishLaunchingNotification">
    <summary>Notification constant for DidFinishLaunching</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIApplication.Notifications.ObserveDidFinishLaunching" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidFinishLaunching ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("Url", args.Url);
    Console.WriteLine ("SourceApplication", args.SourceApplication);
    Console.WriteLine ("RemoteNotifications", args.RemoteNotifications);
    Console.WriteLine ("LocationLaunch", args.LocationLaunch);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIApplicationLaunchEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("Url", args.Url);
    Console.WriteLine ("SourceApplication", args.SourceApplication);
    Console.WriteLine ("RemoteNotifications", args.RemoteNotifications);
    Console.WriteLine ("LocationLaunch", args.LocationLaunch);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidFinishLaunching (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidFinishLaunchingNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidFinishLaunchingNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.DidBecomeActiveNotification">
    <summary>Notification constant for DidBecomeActive</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveDidBecomeActive" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidBecomeActive ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidBecomeActive (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidBecomeActiveNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidBecomeActiveNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.WillTerminateNotification">
    <summary>Notification constant for WillTerminate</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveWillTerminate" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillTerminate ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillTerminate (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillTerminateNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillTerminateNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.WillResignActiveNotification">
    <summary>Notification constant for WillResignActive</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveWillResignActive" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillResignActive ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillResignActive (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillResignActiveNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillResignActiveNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.DidChangeStatusBarOrientationNotification">
    <summary>Notification constant for DidChangeStatusBarOrientation</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIApplication.Notifications.ObserveDidChangeStatusBarOrientation" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidChangeStatusBarOrientation ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIStatusBarOrientationChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidChangeStatusBarOrientation (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidChangeStatusBarOrientationNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidChangeStatusBarOrientationNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.SignificantTimeChangeNotification">
    <summary>Notification constant for SignificantTimeChange</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveSignificantTimeChange" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveSignificantTimeChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveSignificantTimeChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.SignificantTimeChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.SignificantTimeChangeNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.WillChangeStatusBarOrientationNotification">
    <summary>Notification constant for WillChangeStatusBarOrientation</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIApplication.Notifications.ObserveWillChangeStatusBarOrientation" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillChangeStatusBarOrientation ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIStatusBarOrientationChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillChangeStatusBarOrientation (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillChangeStatusBarOrientationNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillChangeStatusBarOrientationNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.WillEnterForegroundNotification">
    <summary>Notification constant for WillEnterForeground</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveWillEnterForeground" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillEnterForeground ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillEnterForeground (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillEnterForegroundNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillEnterForegroundNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.WillChangeStatusBarFrameNotification">
    <summary>Notification constant for WillChangeStatusBarFrame</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIApplication.Notifications.ObserveWillChangeStatusBarFrame" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillChangeStatusBarFrame ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIStatusBarFrameChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillChangeStatusBarFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillChangeStatusBarFrameNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillChangeStatusBarFrameNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.DidReceiveMemoryWarningNotification">
    <summary>Notification constant for DidReceiveMemoryWarning</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveDidReceiveMemoryWarning" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidReceiveMemoryWarning ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidReceiveMemoryWarning (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidReceiveMemoryWarningNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidReceiveMemoryWarningNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.DidChangeStatusBarFrameNotification">
    <summary>Notification constant for DidChangeStatusBarFrame</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIApplication.Notifications.ObserveDidChangeStatusBarFrame" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidChangeStatusBarFrame ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIStatusBarFrameChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidChangeStatusBarFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidChangeStatusBarFrameNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidChangeStatusBarFrameNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.LaunchOptionsNewsstandDownloadsKey">
    <summary>Launch Options Key: This key indicates that Newsstand has completed downloading the requested data. </summary>
    <value>Represents the value associated with the constant UIApplicationLaunchOptionsNewsstandDownloadsKey
        </value>
    <remarks>
      <para>
          The value in the dictionary for this key, contains an array of strings that represent <see cref="Newsstand.NKAssetDownload" /> objects.</para>
      <para>This key is used with the <see cref="Foundation.NSDictionary" /> passed to <see cref="UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)" /></para>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.ProtectedDataWillBecomeUnavailable">
    <summary>Indicates that the state of protected data has changed.</summary>
    <value>To be added.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ProtectedDataWillBecomeUnavailable, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ProtectedDataWillBecomeUnavailable, Callback);
}
]]></code>
      </example>
    </remarks>
    <altmember cref="UIKit.UIApplication.ProtectedDataAvailable" />
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.ProtectedDataDidBecomeAvailable">
    <summary>Indicates that the state of protected data has changed.</summary>
    <value>To be added.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ProtectedDataDidBecomeAvailable, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ProtectedDataDidBecomeAvailable, Callback);
}
]]></code>
      </example>
    </remarks>
    <altmember cref="UIKit.UIApplication.ProtectedDataAvailable" />
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.DidEnterBackgroundNotification">
    <summary>Notification constant for DidEnterBackground</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveDidEnterBackground" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidEnterBackground ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidEnterBackground (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidEnterBackgroundNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidEnterBackgroundNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.ContentSizeCategoryChangedNotification">
    <summary>Notification constant for ContentSizeCategoryChanged</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIApplication.Notifications.ObserveContentSizeCategoryChanged" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveContentSizeCategoryChanged ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("WeakNewValue", args.WeakNewValue);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIContentSizeCategoryChangedEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("WeakNewValue", args.WeakNewValue);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveContentSizeCategoryChanged (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ContentSizeCategoryChangedNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ContentSizeCategoryChangedNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.BackgroundRefreshStatusDidChangeNotification">
    <summary>Notification constant for BackgroundRefreshStatusDidChange</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.BackgroundRefreshStatusDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.BackgroundRefreshStatusDidChangeNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="P:UIKit.UIApplication.UserDidTakeScreenshotNotification">
    <summary>Notification constant for UserDidTakeScreenshot</summary>
    <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
    <remarks>
      <para id="tool-remark">This constant can be used with the <see cref="Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
      <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="UIKit.UIApplication.Notifications" />.<see cref="UIKit.UIKit.UIApplication.Notifications.ObserveUserDidTakeScreenshot" /> method which offers strongly typed access to the parameters of the notification.</para>
      <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveUserDidTakeScreenshot ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveUserDidTakeScreenshot (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
      <para>The following example shows how to use the notification with the DefaultCenter API:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.UserDidTakeScreenshotNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.UserDidTakeScreenshotNotification, Callback);
}
]]></code>
      </example>
    </remarks>
  </Docs>
  <Docs DocId="M:UIKit.UIApplication.Main(System.String[],System.String,System.String)">
        <param name="args">Command line parameters from the Main program.</param>
        <param name="principalClassName">The name of the main application class, if you specify null, this uses UIApplication.</param>
        <param name="delegateClassName">The name of the UIApplicationDelegate class, if null, it uses the UIApplicationDelegate instance specified in the main NIB file for this program..</param>
        <summary>Launches the main application loop with the given command line parameters.</summary>
        <remarks>
          <para>The <paramref name="principalClassName" /> is typically only specified if the application developer subclasses <see cref="UIKit.UIApplication" />, as shown in the following example:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
public class Application
{
	static void Main(string[] args)
	{
		UIApplication.Main(args, "MyApp", "MyAppDelegate");
	}
}

[Register("MyApp")]
public class MyApp : UIApplication
{
//...etc...
}          

[Register("MyAppDelegate")]
public  class AppDelegate : UIApplicationDelegate
{
//..etc...
}
              ]]></code>
          </example>
        </remarks>
      </Docs>
  <Docs DocId="M:UIKit.UIApplication.Main(System.String[],System.Type,System.Type)">
        <param name="args">Command line parameters from the Main program.</param>
        <param name="principalClass">The type of the main application class, if you specify null, this uses UIApplication.</param>
        <param name="delegateClass">The type of the UIApplicationDelegate class, if null, it uses the UIApplicationDelegate instance specified in the main NIB file for this program..</param>
        <summary>Launches the main application loop with the given command line parameters.</summary>
        <remarks>
          <para>The <paramref name="principalClass" /> is typically only specified if the application developer subclasses <see cref="UIKit.UIApplication" />, as shown in the following example:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
public class Application
{
  static void Main(string[] args)
  {
    UIApplication.Main(args, typeof (MyApp), typeof (MyAppDelegate));
  }
}

public class MyApp : UIApplication
{
//...etc...
}          

public class MyAppDelegate : UIApplicationDelegate
{
//..etc...
}
              ]]></code>
          </example>
        </remarks>
      </Docs>
</Documentation>